<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Factory Defense – Phaser Starter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <style>
    html,body{margin:0;height:100%;background:#1e1b1b;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #game{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
(() => {
  const W = 960, H = 540;
  const beltY = H/2;                 // 컨베이어 중앙 Y
  const lanes = [H*0.33, H*0.67];    // 좀비는 바닥 라인만 이동
  const startCoins = 150;

  // 리소스/상태
  let coins = startCoins, parts = 0, wave = 1, baseHP = 120, gameOver = false;
  let produceCost = 25, upgradeLevel = 0, upgradeCost = 60;
  let lastCrateAt = 0, crateInterval = 25000;

  class Main extends Phaser.Scene {
    constructor(){ super('main'); }

    preload(){
      this.load.image('zombieLeft', 'https://i.imgur.com/NZN3Gcf.png');
      this.load.image('zombieRight', 'https://i.imgur.com/A28Nf1P.png');
    }

    create(){
      // ---------- 간단 텍스처/아이콘 ----------
      const mkRect = (key,w,h,fill,stroke=0x000000) => {
        const g = this.add.graphics();
        g.fillStyle(fill,1).fillRect(0,0,w,h);
        g.lineStyle(2,stroke,1).strokeRect(0,0,w,h);
        g.generateTexture(key,w,h); g.destroy();
      };

      // 바닥 타일 / 컨베이어 / 도달점(바리케이드) / 도크
      mkRect('tile', 64,64, 0x4b3b33, 0x1b110d);
      mkRect('belt', W-180, 42, 0x2b2b2b, 0x111111);
      mkRect('goal', 16, 360, 0x9c2a2a, 0x000000);     // 좌측 바리케이드(도달점)
      mkRect('dock', 24, 120, 0x2e7d32, 0x000000);     // 우측 상품 적재 지점

      // 제품(기본/유니크/레이저/광역/슬로우) + 총알
      mkRect('prod', 26, 18, 0xffcc33);
      mkRect('prodU',28,20, 0xff8844);
      mkRect('laser', 26, 18, 0xff4444);
      mkRect('aoe',   26, 18, 0x44ff44);
      mkRect('slow',  26, 18, 0x44aaff);
      mkRect('bullet', 8, 4, 0xfff176);

      // 상자
      mkRect('crate', 22,22, 0xff7043);

      // ---------- 배경/장식 ----------
      this.add.text(16,10,'FACTORY DEFENSE – Top-Down (Skull Zombies)',{fontSize:14, color:'#fff'}).setDepth(10);
      for(let x=0;x<W;x+=64) for(let y=60;y<H;y+=64) this.add.image(x+32,y+32,'tile').setAlpha(0.55);
      // 컨베이어
      this.add.image(W/2, beltY, 'belt').setAlpha(0.9);
      // 좌측 도달점(바리케이드)
      this.add.image(28, H/2, 'goal').setAlpha(0.95);
      // 우측 도크(상품 도착지)
      this.add.image(W-42, H/2, 'dock').setAlpha(0.9);

      // ---------- UI ----------
      this.ui = {
        hp: this.add.text(16, 28, '', {fontSize: 16, color:'#ff8585'}),
        info: this.add.text(16, 48, '', {fontSize: 16, color:'#fff'}),
        wave: this.add.text(W/2-30, 16, '', {fontSize: 18, color:'#ffd54f'}).setDepth(10),
        tip: this.add.text(W-240, 16, 'TIP: 상자 클릭, 제품은 컨베이어만', {fontSize: 14, color:'#ddd'})
      };

      // ---------- 그룹 ----------
      this.products = this.add.group();
      this.zombies  = this.physics.add.group();
      this.bullets  = this.physics.add.group({ allowGravity:false });
      this.crates   = this.physics.add.group({ allowGravity:false });

      // 총알 vs 좀비
      this.physics.add.overlap(this.bullets, this.zombies, (b,z) => {
        if(!b.active || !z.active) return;
        z.hp -= b.damage;
        b.destroy();
        if (z.hp <= 0) this.onZombieKilled(z);
      });

      // 버튼들
      this.makeButton(W*0.13, H-40, 130, 48, 'PRODUCE\n'+produceCost+'c', () => this.spawnProduct("basic"));
      this.makeButton(W*0.28, H-40, 130, 48, 'LASER', () => this.spawnProduct("laser"));
      this.makeButton(W*0.43, H-40, 130, 48, 'AoE',   () => this.spawnProduct("aoe"));
      this.makeButton(W*0.58, H-40, 130, 48, 'SLOW',  () => this.spawnProduct("slow"));
      this.btnUpgrade = this.makeButton(W*0.73, H-40, 130, 48, 'UPGRADE\n'+upgradeCost+'c', () => this.doUpgrade());
      this.makeButton(W*0.88, H-40, 130, 48, 'CRAFT\n5 parts', () => this.doCraft());

      // 스폰/웨이브 타이머(확실하게 나오도록 분리)
      this.zombieTimer = this.time.addEvent({ delay: 900, loop: true, callback: () => this.spawnWaveTick() });
      this.waveTimer   = this.time.addEvent({ delay: 15000, loop: true, callback: () => { wave++; this.pop('WAVE ' + wave); this.updateUI(); } });

      // 상자 클릭 수집
      this.input.on('gameobjectdown', (_p, obj) => {
        if (obj.texture && obj.texture.key === 'crate') {
          this.collectCrate(obj);
        }
      });

      this.flashText = this.add.text(W/2, H*0.18, '', {fontSize: 18, color:'#fff'}).setOrigin(0.5).setDepth(20);
      this.updateUI();
    }

    // 해골 스프라이트(간단 드로잉)
    makeSkullTexture(key, face=0xffffff, stroke=0x000000){
      const g = this.add.graphics();
      const w=28, h=28;
      g.fillStyle(face,1).fillCircle(w/2, h/2, 12);
      g.lineStyle(2, stroke, 1).strokeCircle(w/2, h/2, 12);
      // 눈
      g.fillStyle(0x111111,1).fillCircle(w/2-5, h/2-3, 3);
      g.fillCircle(w/2+5, h/2-3, 3);
      // 이빨
      g.lineStyle(2, 0x111111, 1);
      g.beginPath(); g.moveTo(w/2-6, h/2+6); g.lineTo(w/2+6, h/2+6); g.strokePath();
      g.generateTexture(key, w, h); g.destroy();
    }

    // 공용 버튼
    makeButton(x,y,w,h,label,handler){
      const g = this.add.rectangle(x,y,w,h,0x3a2f24).setStrokeStyle(3,0x000000).setInteractive({useHandCursor:true});
      const t = this.add.text(x,y,label,{fontSize:16, align:'center', color:'#ffd180'}).setOrigin(0.5);
      g.on('pointerdown', ()=>{ if(!gameOver) handler(); this.updateUI(); });
      return { g,t, setLabel:(s)=>t.setText(s) };
    }

    // 제품(이동형 터렛)
    spawnProduct(type="basic"){
      let key, hp, range, damage, fireDelay;

      if(type==="laser"){ key="laser"; hp=30; range=300; damage=20; fireDelay=1500; }
      else if(type==="aoe"){ key="aoe"; hp=38; range=130; damage=16; fireDelay=1200; }
      else if(type==="slow"){ key="slow"; hp=42; range=150; damage=4;  fireDelay=1100; }
      else { key="prod"; hp=40; range=160; damage=8;  fireDelay=520; }

      if (coins < produceCost){ this.pop('코인이 부족합니다'); return; }
      coins -= produceCost;

      const prod = this.physics.add.image(64, beltY, key).setDepth(2);
      prod.hp = hp;
      prod.range = range + upgradeLevel*10;
      prod.damage = damage * (1 + upgradeLevel*0.25);
      prod.fireDelay = fireDelay;
      prod.fireCd = 0;
      prod.body.setVelocityX(60);
      prod.body.setAllowGravity(false);
      prod.prodType = type;

      this.products.add(prod);
      this.updateUI();
    }

    // 업그레이드
    doUpgrade(){
      if (coins < upgradeCost){ this.pop('업그레이드 비용 부족'); return; }
      coins -= upgradeCost;
      upgradeLevel++;
      upgradeCost = Math.round(upgradeCost * 1.55);
      this.btnUpgrade.setLabel('UPGRADE\n'+upgradeCost+'c');
      this.pop('공장 성능 상승! (Lvl '+upgradeLevel+')');
    }

    // 유니크 제작
    doCraft(){
      if (parts < 5){ this.pop('파츠가 부족합니다 (5 필요)'); return; }
      parts -= 5;
      // 유니크는 prodU 키로, 스탯 보정만 추가
      const p = this.physics.add.image(64, beltY, 'prodU').setDepth(2);
      p.hp = 80; p.range = 220 + upgradeLevel*10; p.damage = 14 * (1 + upgradeLevel*0.25);
      p.fireDelay = 400; p.fireCd = 0;
      p.body.setVelocityX(60); p.body.setAllowGravity(false); p.prodType = 'basic';
      this.products.add(p);
      this.pop('유니크 제품 생산!');
      this.updateUI();
    }

    // 주기 스폰(좀비 + 특별 상자)
    spawnWaveTick(){
      if (gameOver) return;

      // 상자
      if (this.time.now - lastCrateAt > crateInterval) {
        lastCrateAt = this.time.now;
        const c = this.physics.add.image(Phaser.Math.Between(140, W-140), Phaser.Math.Between(110, H-150), 'crate')
          .setInteractive({ useHandCursor:true });
        c.setDepth(5); c.reward = Phaser.Math.Between(0,1) ? 'coins':'parts';
        this.crates.add(c);
        this.pop('특별 상자 도착! 클릭해서 획득');
      }

      // 좀비 스폰 (확률적으로 로봇/보스)
      const roll = Phaser.Math.Between(0,100);
      let kind = 'worker';
      if (roll > 90) kind = 'boss';
      else if (roll > 72) kind = 'robot';
      this.spawnZombie(kind);

      this.updateUI();
    }

    spawnZombie(kind='worker'){
      const laneY = Phaser.Utils.Array.GetRandom(lanes);
      const z = this.physics.add.image(-36, laneY, 'zombieRight');
      z.kind = kind;
      z.hp = (kind==='boss'? 240 : kind==='robot'? 55 : 70) * (1 + (wave-1)*0.18);
      z.speed = (kind==='boss'? 26 : kind==='robot'? 95 : 58) * (1 + (wave-1)*0.04);
      z.attack = (kind==='boss'? 14 : kind==='robot'? 6 : 8) * (1 + (wave-1)*0.08);
      z.body.setAllowGravity(false);
      z.setDepth(3);
      z.setVelocityX(z.speed);            // 오른쪽으로 이동
      this.zombies.add(z);
    }

    // 처치 보상
    onZombieKilled(z){
      const coinGain = Phaser.Math.Between(6,11);
      coins += coinGain;
      if (Phaser.Math.Between(0,100) < 22) parts += 1;
      const t = this.add.text(z.x, z.y-18, '+'+coinGain+'c', {fontSize:14,color:'#ffd54f'}).setDepth(10);
      this.tweens.add({ targets:t, y: t.y-20, alpha:0, duration:700, onComplete:()=>t.destroy() });
      z.destroy();
      this.updateUI();
    }

    // 상자 보상
    collectCrate(c){
      if (!c.active) return;
      if (c.reward === 'coins') coins += 40; else parts += 2;
      this.pop('상자 획득! ' + (c.reward==='coins'? '+40 coins' : '+2 parts'));
      c.destroy();
      this.updateUI();
    }

    // 메인 업데이트 루프
    update(_t, dtMs){
      if (gameOver) return;
      const dt = dtMs/1000;

      // 제품 동작
      this.products.getChildren().forEach(p => {
        if (!p.active) return;

        // 사격
        p.fireCd -= dtMs;
        if (p.fireCd <= 0){
          const target = this.findTarget(p.x, p.y, p.range);
          if (target){
            if(p.prodType==="laser") this.fireLaser(p,target);
            else if(p.prodType==="aoe") this.fireAoE(p);
            else if(p.prodType==="slow") this.fireSlow(p);
            else this.fireBullet(p.x,p.y,target,p.damage);
            p.fireCd = p.fireDelay;
          }
        }

        // 도크(오른쪽) 도착 → 소정의 환급
        if (p.x > W-70){
          coins += 10;
          this.pop('+10c (적재 보너스)');
          p.destroy();
        }
      });

      // 좀비: 바리케이드 도달/제품 스침 공격
      this.zombies.getChildren().forEach(z => {
        if (!z.active) return;

        // 우측 바리케이드 도착
        if (z.x > W-36){
          baseHP -= 10;   // 도달 데미지
          z.destroy();
          if (baseHP <= 0) this.endGame();
          return;
        }

        // 컨베이어에 근접 시 지나가며 제품에 피해(좀비는 멈추지 않음)
        this.products.getChildren().forEach(p => {
          if (!p.active) return;
          if (Math.abs(z.y - beltY) < 36 && Math.abs(z.x - p.x) < 32){
            p.hp -= z.attack * dt;
            if (p.hp <= 0) p.destroy();
          }
        });
      });

      // 주기적 UI 갱신
      if (this._uiTick == null) this._uiTick = 0;
      this._uiTick += dtMs;
      if (this._uiTick > 200) { this.updateUI(); this._uiTick = 0; }
    }

    // 타깃 탐색
    findTarget(x,y,range){
      let best=null, bestD=1e9;
      this.zombies.getChildren().forEach(z=>{
        if(!z.active) return;
        const d = Phaser.Math.Distance.Between(x,y,z.x,z.y);
        if(d<range && d<bestD){ best=z; bestD=d; }
      });
      return best;
    }

    // 기본 총알
    fireBullet(x,y,target,damage){
      const b = this.physics.add.image(x, y, 'bullet');
      b.damage = damage; b.setDepth(4);
      b.body.setAllowGravity(false);
      const dx = target.x - x, dy = target.y - y;
      const len = Math.max(0.001, Math.hypot(dx,dy));
      const speed = 340;
      b.setVelocity((dx/len)*speed, (dy/len)*speed);
      this.bullets.add(b);
      this.time.delayedCall(1800, ()=> b.destroy());
    }

    // 레이저(관통 라인)
    fireLaser(p,target){
      const g = this.add.graphics();
      g.lineStyle(2,0xff5252).beginPath();
      g.moveTo(p.x,p.y); g.lineTo(target.x,target.y); g.strokePath();
      this.time.delayedCall(120, ()=>g.destroy());
      this.zombies.getChildren().forEach(z=>{
        if(Math.abs(z.y-p.y)<24 && z.x>p.x && z.x<p.x+p.range){
          z.hp -= p.damage;
          if(z.hp<=0) this.onZombieKilled(z);
        }
      });
    }

    // 광역(폭발)
    fireAoE(p){
      const r = p.range*0.45;
      const g = this.add.circle(p.x, p.y, r, 0xfff176, 0.25).setDepth(5);
      this.time.delayedCall(230, ()=>g.destroy());
      this.zombies.getChildren().forEach(z=>{
        if(Phaser.Math.Distance.Between(p.x,p.y,z.x,z.y)<r){
          z.hp -= p.damage;
          if(z.hp<=0) this.onZombieKilled(z);
        }
      });
    }

    // 슬로우(광역 감속)
    fireSlow(p){
      const r = p.range*0.42;
      const g = this.add.circle(p.x, p.y, r, 0x4fc3f7, 0.22).setDepth(5);
      this.time.delayedCall(300, ()=>g.destroy());
      this.zombies.getChildren().forEach(z=>{
        if(Phaser.Math.Distance.Between(p.x,p.y,z.x,z.y)<r){
          z.hp -= p.damage*0.6;               // 약간의 피해
          z.setVelocityX(-z.speed*0.55);      // 감속
          this.time.delayedCall(1400, ()=>{ if(z.active) z.setVelocityX(-z.speed); });
          if(z.hp<=0) this.onZombieKilled(z);
        }
      });
    }

    pop(text){
      this.flashText.setText(text).setAlpha(1);
      this.tweens.add({ targets: this.flashText, alpha:0, duration:900, ease:'Sine.easeOut' });
    }

    updateUI(){
      this.ui.hp.setText('Barricade HP: ' + Math.max(0,Math.round(baseHP)));
      this.ui.info.setText(`Coins: ${coins}   Parts: ${parts}   UpgLv: ${upgradeLevel}`);
      this.ui.wave.setText('WAVE ' + wave);
    }

    endGame(){
      gameOver = true;
      this.add.rectangle(W/2,H/2, W, H, 0x000000, 0.6).setDepth(50);
      this.add.text(W/2, H/2, 'GAME OVER', {fontSize:48, color:'#ff7777'}).setOrigin(0.5).setDepth(51);
      this.add.text(W/2, H/2+44, 'Refresh to restart', {fontSize:18, color:'#fff'}).setOrigin(0.5).setDepth(51);
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: W, height: H,
    backgroundColor: '#231f1f',
    parent: 'game',
    physics: { default:'arcade', arcade:{ debug:false } },
    scene: [Main]
  };

  new Phaser.Game(config);
})();
</script>
</body>
</html>
