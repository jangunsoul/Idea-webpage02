<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Defend the Factory</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#1e1b1b;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #game{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{image-rendering:pixelated}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
(() => {
  const W=960, H=540;
  const VERSION='0.0.17';
  let coins=300;
  let baseHP=200;
  const base={x:W/2,y:272,width:448,height:160,hp:200,maxHp:200};
  let wave=1;

  class Boot extends Phaser.Scene {
    constructor(){ super('boot'); }
    preload(){
      // sprites
      this.load.spritesheet('zombie','resources/sprites/zombie.png',{frameWidth:32,frameHeight:32});
      this.load.spritesheet('robot','resources/sprites/robot.png',{frameWidth:48,frameHeight:48});
      this.load.spritesheet('boss','resources/sprites/boss.png',{frameWidth:48,frameHeight:48});
      this.load.image('turret','resources/sprites/product_turret.png');
      // tiles
      this.load.spritesheet('conveyor','resources/tiles/conveyor.png',{frameWidth:32,frameHeight:32});
      this.load.spritesheet('conveyor_corner','resources/tiles/conveyor_cross.png',{frameWidth:32,frameHeight:32});
      this.load.image('floor','resources/tiles/floor.png');
      this.load.image('out','resources/tiles/out.png');
      // ui
      this.load.image('coin','resources/ui/coin.png');
      this.load.image('wave_banner','resources/ui/wave_banner.png');
      this.load.image('btn_produce','resources/ui/btn_produce.png');
      this.load.image('chest','resources/ui/chest.png');
      this.load.image('pickup_dollar','resources/ui/pickup_dollar.png');
      // effects
      this.load.image('laser','resources/effects/laser.png');
      this.load.image('bullet','resources/effects/bullet.png');
      this.load.spritesheet('explosion','resources/effects/explosion.png',{frameWidth:32,frameHeight:32});
    }
    create(){
      this.anims.create({key:'zombie_walk',frames:this.anims.generateFrameNumbers('zombie',{start:0,end:3}),frameRate:6,repeat:-1});
      this.anims.create({key:'robot_walk',frames:this.anims.generateFrameNumbers('robot',{start:0,end:2}),frameRate:6,repeat:-1});
      this.anims.create({key:'boss_walk',frames:this.anims.generateFrameNumbers('boss',{start:0,end:1}),frameRate:4,repeat:-1});
      // slow the belt animation so tiles appear to move more gently
      this.anims.create({key:'belt_move',frames:this.anims.generateFrameNumbers('conveyor',{start:0,end:1}),frameRate:3,repeat:-1});
      this.anims.create({key:'belt_corner',frames:this.anims.generateFrameNumbers('conveyor_corner',{start:0,end:1}),frameRate:3,repeat:-1});
      this.anims.create({key:'explode',frames:this.anims.generateFrameNumbers('explosion',{start:0,end:3}),frameRate:12,hideOnComplete:true});
      this.scene.start('title');
    }
  }

  class Title extends Phaser.Scene {
    constructor(){ super('title'); }
    create(){
      this.add.text(W/2,H/2-60,'Defend the Factory',{fontSize:48,color:'#fff'}).setOrigin(0.5);
      this.add.text(W/2,H/2,'Version '+VERSION,{fontSize:20,color:'#fff'}).setOrigin(0.5);
      this.add.text(W/2,H/2+60,'Tap to Start',{fontSize:24,color:'#fff'}).setOrigin(0.5);
      this.input.once('pointerdown',()=>this.scene.start('quest'));
    }
  }

  class Quest extends Phaser.Scene {
    constructor(){ super('quest'); }
    create(){
      this.add.text(W/2,H/2-20,'Stage 1',{fontSize:32,color:'#fff'}).setOrigin(0.5);
      this.add.text(W/2,H/2+20,'Defend the factory from zombies',{fontSize:24,color:'#fff'}).setOrigin(0.5);
      this.add.text(W/2,H-60,'Tap to Start',{fontSize:24,color:'#fff'}).setOrigin(0.5);
      this.input.once('pointerdown',()=>this.scene.start('main'));
    }
  }

  class Main extends Phaser.Scene {
    constructor(){ super('main'); }
    init(){
      coins=300;
      baseHP=200;
      base.hp=200;
      base.maxHp=200;
      wave=1;
    }
    create(){
      // floor is a plain background with no physics body so enemies can cross freely
      this.add.tileSprite(0,0,W,H,'floor').setOrigin(0).setDepth(-1);

      // build conveyor loop
      this.buildConveyor();

      // path for products starting at the out tile
      this.path=new Phaser.Curves.Path(480,352);
      this.path.lineTo(704,352).lineTo(704,192).lineTo(256,192).lineTo(256,352).lineTo(480,352);

      // groups
      this.products=this.add.group();
      this.enemies=this.physics.add.group({allowGravity:false,collideWorldBounds:false});
      this.lasers=this.add.group();
      this.drops=this.physics.add.group({allowGravity:false});
      this.gameOver=false;

      // enemies collide with conveyor tiles or products
      this.physics.add.collider(this.enemies,this.conveyorTiles,(e)=>{e.body.stop();e.atBase=true;});
      this.physics.add.collider(this.enemies,this.products,(e,p)=>{e.body.stop();e.target=p;});

      // UI
      this.buildUI();
      this.nextQueue=[this.randomEnemyType(),this.randomEnemyType(),this.randomEnemyType()];
      this.updateNextIcons();
      this.updateUI();

      // spawn timer
      this.spawnDelay=4500;
      this.spawnEnemy();
    }

    buildConveyor(){
      this.conveyorTiles=this.physics.add.staticGroup();
      // straight segments
      for(let x=256;x<=704;x+=32){
        this.conveyorTiles.create(x,192,'conveyor').play('belt_move');
        this.conveyorTiles.create(x,352,'conveyor').play('belt_move');
      }
      for(let y=224;y<352;y+=32){
        const t1=this.conveyorTiles.create(256,y,'conveyor').setAngle(90).play('belt_move');
        t1.refreshBody();
        const t2=this.conveyorTiles.create(704,y,'conveyor').setAngle(90).play('belt_move');
        t2.refreshBody();
      }
      // corners
      const c1=this.conveyorTiles.create(256,192,'conveyor_corner').setAngle(180).play('belt_corner');
      c1.refreshBody();
      const c2=this.conveyorTiles.create(704,192,'conveyor_corner').setAngle(270).play('belt_corner');
      c2.refreshBody();
      const c3=this.conveyorTiles.create(256,352,'conveyor_corner').setAngle(90).play('belt_corner');
      c3.refreshBody();
      const c4=this.conveyorTiles.create(704,352,'conveyor_corner').setAngle(0).play('belt_corner');
      c4.refreshBody();
      // out tile
      const out=this.conveyorTiles.create(480,352,'out').setOrigin(0.5,0);
      out.refreshBody();
    }

    buildUI(){
      // next enemy preview
      const box=this.add.rectangle(16,16,128,64,0x000000,0.3).setOrigin(0).setStrokeStyle(2,0xffffff);
      this.add.text(24,24,'Next',{fontSize:16,color:'#fff'});
      this.nextIcons=[];
      for(let i=0;i<3;i++){
        const icon=this.add.sprite(48+i*40,56,'zombie',0);
        this.nextIcons.push(icon);
      }

      // wave banner and hp bar
      this.add.image(W/2,16,'wave_banner').setOrigin(0.5,0);
      this.waveText=this.add.text(W/2,28,'WAVE '+wave,{fontSize:20,color:'#fff'}).setOrigin(0.5);
      this.hpLabel=this.add.text(W/2-110,76,'HP',{fontSize:16,color:'#fff'}).setOrigin(0.5);
      this.hpBarBg=this.add.rectangle(W/2,80,200,16,0x555555).setOrigin(0.5);
      this.hpBar=this.add.rectangle(W/2-100,80,200,16,0xff7f00).setOrigin(0,0.5);
      this.hpValue=this.add.text(W/2+110,76,String(baseHP),{fontSize:16,color:'#fff'}).setOrigin(1,0.5);

      // coin counter
      this.add.image(W-40,24,'coin');
      this.coinText=this.add.text(W-48,16,'0',{fontSize:18,color:'#fff'}).setOrigin(1,0);

      // production slots
      this.slots=[];
      this.slotOverlays=[];
      this.cooldowns=[0,0,0];
      for(let i=0;i<3;i++){
        const s=this.add.rectangle(64+i*72,H-48,64,64,0x000000,0.3)
          .setStrokeStyle(2,0xffffff).setOrigin(0.5)
          .setInteractive({useHandCursor:true});
        this.slots.push(s);
        const ov=this.add.rectangle(s.x,s.y+32,64,64,0x000000,0.6)
          .setOrigin(0.5,1).setVisible(false);
        this.slotOverlays.push(ov);
      }
      // turret product in first slot
      const turretIcon=this.add.image(this.slots[0].x,this.slots[0].y,'turret').setInteractive({useHandCursor:true});
      turretIcon.on('pointerdown',()=>this.slots[0].emit('pointerdown'));
      this.add.image(this.slots[0].x-20,this.slots[0].y+20,'coin').setScale(0.75);
      this.add.text(this.slots[0].x-6,this.slots[0].y+12,'50',{fontSize:14,color:'#fff'});
      this.slots[0].on('pointerdown',()=>{
        if(coins>=50 && this.canPlaceProduct() && this.cooldowns[0]<=0){
          coins-=50; this.spawnProduct(); this.updateUI();
          this.cooldowns[0]=5000;
          const ov=this.slotOverlays[0];
          ov.setVisible(true); ov.setDisplaySize(64,64);
        }
      });
    }

    canPlaceProduct(){
      return !this.products.getChildren().some(p=>p.progress<0.08);
    }

    addHPBar(obj,color){
      obj.maxHp=obj.hp;
      obj.hpBar=this.add.rectangle(obj.x,obj.y-20,obj.displayWidth,4,color).setOrigin(0.5);
    }

    spawnProduct(){
      const p=this.add.sprite(0,0,'turret');
      this.physics.add.existing(p);
      p.body.setAllowGravity(false);
      p.body.setImmovable(true);
      p.progress=0;
      const start=this.path.getPoint(0);
      p.setPosition(start.x,start.y);
      // reduce conveyor traversal speed by half
      p.speed=0.00005; // progress per ms
      p.range=128;
      p.damage=30;
      p.fireRate=1000;
      p.cooldown=0;
      p.hp=15;
      this.addHPBar(p,0x00ff00);
      this.products.add(p);
    }

    randomEnemyType(){
      const r=Math.random();
      if(r<0.8) return 'zombie';
      if(r<0.95) return 'robot';
      return 'boss';
    }

    updateNextIcons(){
      this.nextIcons.forEach((icon,i)=>{
        const t=this.nextQueue[i];
        icon.setTexture(t).setFlipX(true);
        if(t==='zombie') icon.setScale(1); else icon.setScale(32/48);
      });
    }

    spawnEnemy(){
      // spawn at a random screen edge but slightly inside the bounds
      const margin=32;
      const edge=Phaser.Math.Between(0,3);
      let x,y;
      if(edge===0){ // left
        x=margin; y=Phaser.Math.Between(margin,H-margin);
      }else if(edge===1){ // right
        x=W-margin; y=Phaser.Math.Between(margin,H-margin);
      }else if(edge===2){ // top
        x=Phaser.Math.Between(margin,W-margin); y=margin;
      }else{ // bottom
        x=Phaser.Math.Between(margin,W-margin); y=H-margin;
      }

      const type=this.nextQueue.shift();
      let key=type,anim=type+'_walk',hp=100,speed=30,attackRate=2000,damage=5,range=32,style='melee';
      if(type==='robot'){hp=80;speed=40;attackRate=2000;damage=6;range=96;style='laser';}
      else if(type==='boss'){hp=200;speed=20;attackRate=500;damage=3;range=112;style='bullet';}

      const e=this.enemies.create(x,y,key).setCollideWorldBounds(false);
      if(type==='robot') e.setScale(0.5);
      else e.setScale(1);
      e.body.setAllowGravity(false);
      e.anims.play(anim);
      e.hp=hp;
      e.attackRate=attackRate;
      e.attackTimer=attackRate;
      e.attackDamage=damage;
      e.attackRange=range;
      e.attackStyle=style;
      e.burst=0;
      e.atBase=false;
      this.addHPBar(e,0xff0000);

      // move toward conveyor center
      const targetX=W/2, targetY=H/2;
      this.physics.moveTo(e,targetX,targetY,speed);
      e.speed=speed;
      e.setFlipX(e.body.velocity.x>0);

      this.nextQueue.push(this.randomEnemyType());
      this.updateNextIcons();

      // schedule next spawn with accelerating delay
      this.spawnDelay=Math.max(1000,this.spawnDelay*0.97);
      this.time.delayedCall(this.spawnDelay,this.spawnEnemy,[],this);
    }

    killEnemy(e){
      this.add.sprite(e.x,e.y,'explosion').play('explode');
      const drop=this.add.image(e.x,e.y,'coin');
      this.time.delayedCall(500,()=>{
        this.tweens.add({targets:drop,x:W-40,y:24,duration:500,onComplete:()=>{coins+=10;drop.destroy();this.updateUI();}});
      });
      if(e.hpBar) e.hpBar.destroy();
      e.destroy();
    }

    killProduct(p){
      this.add.sprite(p.x,p.y,'explosion').play('explode');
      if(p.hpBar) p.hpBar.destroy();
      p.destroy();
    }

    fireLaser(shooter,target,damage,damageTarget){
      const angle=Phaser.Math.Angle.Between(shooter.x,shooter.y,target.x,target.y);
      const dist=Phaser.Math.Distance.Between(shooter.x,shooter.y,target.x,target.y);
      const beam=this.add.image(shooter.x,shooter.y,'laser').setOrigin(0,0.5);
      beam.setRotation(angle);
      beam.setDisplaySize(dist,4);
      this.lasers.add(beam);
      this.time.delayedCall(100,()=>beam.destroy());
      this.applyDamage(damageTarget||target,damage);
    }

    fireBullet(shooter,target,damage,damageTarget){
      const bullet=this.add.image(shooter.x,shooter.y,'bullet');
      this.tweens.add({targets:bullet,x:target.x,y:target.y,duration:200,onComplete:()=>{
        bullet.destroy();
        this.applyDamage(damageTarget||target,damage);
      }});
    }

    applyDamage(target,damage){
      target.hp-=damage;
      if(target===base){
        baseHP=target.hp;
        this.updateUI();
        if(baseHP<=0 && !this.gameOver){
          this.gameOver=true;
          this.time.delayedCall(100,()=>this.showGameOver());
        }
        return;
      }
      if(target.hp<=0){
        if(this.enemies.contains(target)){
          this.killEnemy(target);
        }else if(this.products.contains(target)){
          this.killProduct(target);
        }
      }else if(target.hpBar){
        target.hpBar.width=target.displayWidth*(target.hp/target.maxHp);
      }
    }

    enemyAttack(e,target){
      if(target===base){
        const tx=Phaser.Math.Clamp(e.x,base.x-base.width/2,base.x+base.width/2);
        const ty=Phaser.Math.Clamp(e.y,base.y-base.height/2,base.y+base.height/2);
        const point={x:tx,y:ty};
        if(e.attackStyle==='laser'){
          this.fireLaser(e,point,e.attackDamage,base);
        }else if(e.attackStyle==='bullet'){
          this.fireBullet(e,point,e.attackDamage,base);
        }else{
          this.applyDamage(base,e.attackDamage);
        }
      }else if(e.attackStyle==='laser'){
        this.fireLaser(e,target,e.attackDamage);
      }else if(e.attackStyle==='bullet'){
        this.fireBullet(e,target,e.attackDamage);
      }else{
        if(target.setTintFill){
          target.setTintFill(0xffffff);
          this.time.delayedCall(100,()=>target.clearTint && target.clearTint());
        }
        this.applyDamage(target,e.attackDamage);
      }
      if(e.texture.key==='boss'){
        e.burst+=1;
        if(e.burst>=3){
          e.attackTimer=2000;
          e.burst=0;
        }else{
          e.attackTimer=e.attackRate;
        }
      }else{
        e.attackTimer=e.attackRate;
      }
    }

    showGameOver(){
      const t=this.add.text(W/2,H/2,'Game Over\nTap to Restart',{fontSize:48,color:'#fff',align:'center'}).setOrigin(0.5);
      this.input.once('pointerdown',()=>{t.destroy(); this.scene.restart();});
    }

    getTarget(p){
      let best=null,bestD=1e9;
      this.enemies.getChildren().forEach(z=>{
        const d=Phaser.Math.Distance.Between(p.x,p.y,z.x,z.y);
        if(d<p.range && d<bestD){best=z;bestD=d;}
      });
      return best;
    }

    update(_t,dt){
      // move products along path
      this.products.getChildren().forEach(p=>{
        p.progress+=p.speed*dt;
        if(p.progress>1) p.progress-=1;
        const pt=this.path.getPoint(p.progress);
        p.setPosition(pt.x,pt.y);
        if(p.hpBar) p.hpBar.setPosition(p.x,p.y-20);
        p.cooldown-=dt;
        if(p.cooldown<=0){
          const t=this.getTarget(p);
          if(t){this.fireLaser(p,t,p.damage);p.cooldown=p.fireRate;}
        }
      });

      this.enemies.getChildren().forEach(e=>{
        if(e.hpBar) e.hpBar.setPosition(e.x,e.y-20);
        if(e.target && (!e.target.active || Phaser.Math.Distance.Between(e.x,e.y,e.target.x,e.target.y)>e.attackRange)){
          e.target=null;
        }

        let tgt=e.target;
        if(!tgt){
          const prod=this.products.getChildren().find(p=>Phaser.Math.Distance.Between(e.x,e.y,p.x,p.y)<=e.attackRange);
          if(prod){ e.target=prod; tgt=prod; }
          else tgt=base;
        }

        if(e.attackStyle!=='melee'){
          const dist=Phaser.Math.Distance.Between(e.x,e.y,tgt.x,tgt.y);
          if(dist<=e.attackRange*0.8){
            e.body.setVelocity(0);
            if(tgt===base) e.atBase=true;
          }else{
            this.physics.moveTo(e,tgt.x,tgt.y,e.speed);
          }
        }else if(!e.atBase && !e.target){
          const targetX=W/2, targetY=H/2;
          this.physics.moveTo(e,targetX,targetY,e.speed);
        }

        if(e.target){
          e.attackTimer-=dt;
          if(e.attackTimer<=0){
            this.enemyAttack(e,e.target);
          }
        }else if(e.atBase){
          e.attackTimer-=dt;
          if(e.attackTimer<=0){
            this.enemyAttack(e,base);
          }
        }
      });

      // update production slot cooldown overlays
      this.cooldowns.forEach((cd,i)=>{
        if(cd>0){
          this.cooldowns[i]-=dt;
          const ratio=this.cooldowns[i]/5000;
          const ov=this.slotOverlays[i];
          ov.setDisplaySize(64,64*ratio);
          ov.x=this.slots[i].x;
          ov.y=this.slots[i].y+32;
          if(this.cooldowns[i]<=0){
            ov.setVisible(false);
            this.cooldowns[i]=0;
          }else{
            ov.setVisible(true);
          }
        }
      });
    }

    updateUI(){
      this.coinText.setText(coins);
      this.hpValue.setText(baseHP);
      this.hpBar.width=200*(baseHP/200);
      base.hp=baseHP;
    }
  }

  const config={
    type:Phaser.AUTO,
    width:W,height:H,
    parent:'game',
    backgroundColor:'#1e1b1b',
    physics:{default:'arcade',arcade:{debug:false}},
    scene:[Boot,Title,Quest,Main]
  };
  new Phaser.Game(config);
})();
</script>
</body>
</html>

